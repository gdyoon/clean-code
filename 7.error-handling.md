# 7. 오류 처리

오류 처리는 깨끗한 코드의 프로그램을 작성하는데 반드시 필요한 요소이다. 오류 처리가 잘못되어 있으면, 코드 파악이나 논리를 이해하기 어려워진다.

해당 절에서는 오류를 처리하는 기법과 고려해야 할 사항들에 대해 말할 것이다.

첫째, 오류 코드를 반환하는 행위 보단 예외를 던져라.  
오류코드가 반환되면, 어차피 호출자가 그 즉시 오류 코드를 읽고 처리해야 한다.  
과거에는 예외 처리를 지원하지 않는 언어가 있었지만, 지금은 굳이 사용할 필요는 없다.

둘째, try-catch-finally 구문을 사용해라.  
당연한 얘기겠지만,, 예외가 발생하는 코드를 작성할 땐, try-catch-finally 로 감싸는 것이 좋다.  
절대 예외의 최상위 클래스\(Exception\)를 catch로 잡지 않도록 한다.  
  
자바와 같이 checked exception 을 제공해주는 경우가 있다. 특정 함수를 호출하려면, 반드시 그에 상응하는 exception 을 catch 구문에 강제로 넣어야 하는 경우를 의미하는데, 이런 방식 자체가 좋은 아이디어면서도 구현에 따라 OCP\(Open Closed Principle\) 을 위반하기도 한다.   
  
그러나, 함수의 추상화 수준이 높아지고 깊어질때, 엔트리 포인트가 되는 가장 하위의 함수가 checked exception을 처리해야 하는 경우가 발생한다면, 해당 함수를 구현하거나 아래 함수로 호출하는 상위 함수의 경우에 모두 throws 절을 명시해야하는 연쇄적 수정이 발생한다.

외부에서 불러온 라이브러리의 경우, 수많은 예외를 강제적으로 처리해야 할 경우가 생길 수 있다. 이때, 해당 라이브러리의 wrapper 클래스를 만들어서 사용하면 예외의 의존성을 떼어낼 수 있다.   
가령, ACEMPort 라는 어떤 포트를 정의하는 클래스가 있다고 하자. open\(\) 메서드를 호출하면 아래 두 예외를 반드시 호출해야 하는 구조를 갖고 있다.

* ACEMPort
  * open\(\)
    * DeviceResponseException
    * ATM1212UnlockedException

여기서 wrapper 클래스인 LocalPort 클래스를 정의한다. 내부에 ACEMPort 인스턴스를 생성하고 open\(\) 메서드를 생성하고 실제로는 ACEMPort 객체의 open\(\) 을 호출하도록 한다. 그리고 여기서 중요한 것! PortDeviceFailure 예외가 위의 두 예외를 잡도록 정의한다. 그러면, 모든 예외를 나열할 필요가 없게된다.

* LocalPort
  * open\(\)
    * PortDeviceFailure 

예외를 던지고 특정 예외를 잡는 부분에서 비즈니스 로직을 처리하는 부분이 있을 수 있다. 가령 아래와 같다. 

```text
try {
    Emotion myEmotion = human.getEmotion(gdyoon.getStatus());
} catch (EmotionNotFound e) {
    myEmotion = getHappiness();
}
```

나의 감정 상태 기본 값은 언제나 행복하다. 그러나, 내 상태를 확인하고 감정을 찾을 수 없을 때 행복함이 기본이라 한다면 human.getEmotion\(\) 에서 예외를 던지는 것 보다 기본 값에 해당하는 Emotion 객체를 던지는 것이 훨씬 낫다. 이를 특수 사례 패턴\(Spection Case Pattern\)이라 한다.

이 패턴은 클라이언트에게 예외 처리에 대한 책임을 전가시키지 않으므로 특수한 상황을 처리 할 필요가 없어지게 된다.

